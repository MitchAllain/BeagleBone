#! /usr/bin/env python

##########################################################################################
# autonomous.py
#
# Derived from manual.py
# Autonomous operation of the excavator. Records data and timestamps.
#
# NOTE: SERVO CLASS, INTERPOLATE FUNCTION, AND MISC DEPENDENCIES IMPORTED FROM EXCAVATOR.PY
#
#       controllers act on error until within ball of endpoints in actuator space
#
#
# TODO: - Swing error scaling
#       - Test and validate, timeit()
#       - Fix time on BBB for datastamping
#
# Created: September 27, 2016
#   - Mitchell Allain
#   - allain.mitch@gmail.com
#
# Modified:
#   * September 28, 2016 - changed to autonomous.py, implemented poly func
#   * October 11, 2016 - point to point actuator space trajectories in each
#   * October 11, 2016 - going to switch dependecies to excavator
#   * October 15, 2016 - encoder integration
#   * October 24, 2016 - homing routine factored
#
##########################################################################################

from excavator import *
# import socket
import numpy.polynomial.polynomial as poly
from PID import PID
import pickle


############################### This is old ###########################
# Create some trajectories
# Quintic trajectory's generated by excavator_main.m code
# List of poly coefficients starts with lowest order, i.e., bias term, if duration = 0, then no change
# EXAMPLE
# trajectory_# = [[duration, [list of poly coefficients for BOOM]],
#                 [duration, [list of poly coefficients for STICK]],
#                 [duration, [list of poly coefficients for BUCKET]],
#                 [duration, [list of poly coefficients for SWING]]]
# # Scoop
# trajectory_1 = [[0, [8.185, 0, 0, 0, 0, 0]],
#                 [2.997, [4.63, 0, 0, 1.1889, -0.5951, 0.0794]],
#                 [2.997, [3.5065, 0, 0, 2.3539, -1.1781, 0.1572]],
#                 [0, [0, 0, 0, 0]]]
# # Lift
# trajectory_2 = [[1.8401, [8.185, 0, 0, 2.70153648642975, -2.20225152140528, 0.478731199857935]],
#                 [0, [7.8306]],
#                 [1.8401, [9.84312405487372, 0, 0, 0.0391087577373468, -0.0318808654482269, 0.00693034597555865]],
#                 [0, [1.4255, 0, 0, 0, 0, 0]]]
# # Swing over bucket
# trajectory_3 = [[2.1710, [9.868125, 0, 0, -0.699350608387411, 0.483195299027478, -0.0890264746378990]],
#                 [2.1710, [7.830625, 0, 0, -3.31419104604783, 2.28984076702506, -0.421892455039781]],
#                 [0, [9.8675]],
#                 [2.1710, [1.4255, 0, 0, -1.07167143498860, 0.740439192127892, -0.136422459182765]]]
# # Dump!
# trajectory_4 = [[0, [9.1525]],
#                 [0, [4.4393]],
#                 [2.5302, [9.86748979200047, 0, 0, -2.79917066219767, 1.65942516605294, -0.262334070960657]],
#                 [0, [0.3289]]]
# # Back over pile
# trajectory_5 = [[1.5606, [9.1525, 0, 0, -2.54556135822480, 2.44672801202272, -0.627128518742281]],
#                 [1.5606, [4.43931034482758, 0, 0, 0.501718054387705, -0.482238471228211, 0.123604052700518]],
#                 [1.5606, [5.33310604736383, 0, 0, -4.80587121602322, 4.61927962900013, -1.18398202708129]],
#                 [1.5606, [0.32889, 0, 0, 2.31379029874570, -2.22395563933115, 0.570029034281288]]]

# task = [trajectory_1, trajectory_2, trajectory_3, trajectory_4, trajectory_5]
# home = [8.185, 4.630, 3.5065, 1.4255]
#######################################################################

# Load the pickled task trajectories
pkl_file = open('autonomous_task.pkl', 'rb')
task = pickle.load(pkl_file)
pkl_file.close()

# Initialize PWM/servo classes and measurement classes, note: this zeros the encoder
temp = exc_setup()
actuators = temp[0]
measurements = temp[1]

# Initialize DataLogger class with mode 2 for autonomy
filename = raw_input('Name the output file (end with .csv) or press return to disable data logging: ')
if filename == '':
    print('No data storage selected')
else:
    print('Writing headers to: ' + filename)
    data = DataLogger(2, filename)

# Zero the encoder again
measurements[3].encoder.zero()

# Or preset the value
# measurements[3].encoder.setPosition(1100)

# Set duty cycles to middle, and initialize Measurement classes
for a in actuators:
    a.update_servo()

for b in measurements:
    b.update_measurement()

# PI Controllers for each actuator
boom_PI = PID(1.25, 0.1, 0, 0, 0, 10, -10)
stick_PI = PID(1.25, 0.1, 0, 0, 0, 10, -10)
bucket_PI = PID(1.25, 0.1, 0, 0, 0, 10, -10)
swing_PI = PID(1.75, 0.1, 0, 0, 0, 10, -10)
controllers = [boom_PI, stick_PI, bucket_PI, swing_PI]

# BEGIN HOMING, Homing routine to set point
home = [task[0][i][1][0] for i in range(4)]

# def homing(actuators, measurements, controllers, home):
#     for i in range(4):
#         controllers[i].setPoint(home[i])
#         controllers[i].update(measurements[i].value)
#     # tempstart = time.time()

#     try:
#         while np.linalg.norm([controllers[i].getError() for i in range(2)]+[controllers[3].getError()*30]) > 1:    # 1 cm radius ball about endpoint
#             # Measurement
#             for m in measurements:
#                 m.update_measurement()
#                 # print(m.value)

#             for i in range(4):
#                     # Update actuators with control action
#                     actuators[i].duty_set = controllers[i].update(measurements[i].value) + actuators[i].duty_mid

#             # Update PWM, saturation implemented in Servo class
#             for a in actuators:
#                 a.update_servo()
#                 print(a.actuator_name + ': ' + str(a.duty_set))
#             print('Error' + str(np.linalg.norm([controllers[i].getError() for i in range(2)]+[controllers[3].getError()*30])))

#         for m in measurements:
#             print(m.value)

#         for a in actuators:  # Reset all duty cycles after homing
#             a.duty_set = a.duty_mid
#             a.update_servo()

#     except KeyboardInterrupt:
#         print '\nClosing PWM signals...'
#         for a in actuators:
#             a.duty_set = a.duty_mid
#             a.update_servo()
#         time.sleep(1)
#         for a in actuators:
#             a.close_servo()
# # END HOMING

homing(actuators, measurements, controllers, home, [0.3, 0.3, 0.3, 0.1], 10)
raw_input('Pausing...')
start = time.time()

try:
    while True:
        for trajectory in task:
            # Endpoint error norm triggers trajectory change
            endpoint = [0, 0, 0, 0]
            endpoint_error = [0, 0, 0, 0]

            # Initialize integrator and derivator to zero
            for c in controllers:
                c.setIntegrator(0)
                c.setDerivator(0)

            # Initialize set point for non-active actuators, so that error data is correct
            # for i in range(4):
            #     controllers[i].setPoint(poly.polyval(0, trajectory[i][1]))

            # Determine endpoints for each *active* actuator and an endpoint error vector (actuator space)
            for i in range(4):
                if trajectory[i][0] == 0:
                    endpoint_error[i] = 0
                    endpoint[i] = 0
                else:
                    endpoint[i] = poly.polyval(trajectory[i][0], trajectory[i][1])
                    endpoint_error[i] = measurements[i].value - endpoint[i]
                    endtime = trajectory[i][0]

            endpoint_error[3] = endpoint_error[3]*30  # scale swing error, [0, 1.571] to [0, 45], i.e., 2 degrees are penalized same as 1 cm on actuator

            # Time markers
            traj_start = time.time()
            loop_start = time.time()

            while np.linalg.norm(endpoint_error) > 1 or (loop_start-traj_start) < endtime:    # 1 cm radius ball about endpoint
                loop_start = time.time()

                # Measurement
                for b in measurements:
                    b.update_measurement()

                # Set point update and PI output
                for i in range(4):
                    if trajectory[i][0] != 0:
                        # Change set point only if still within valid trajectory window
                        if (time.time() - traj_start) < trajectory[i][0]:
                            # Note this version of polyval takes coefficients from constant term to highest power
                            controllers[i].setPoint(poly.polyval((time.time()-traj_start), trajectory[i][1]))

                        # Update actuators with control action and endpoint error
                        # actuators[i].duty_set = actuators[i].duty_span*(controllers[i].update(measurements[i].value) + 1)/2 + actuators[i].duty_mid
                        actuators[i].duty_set = controllers[i].update(measurements[i].value) + actuators[i].duty_mid
                        # print(controllers[i].P_value + controllers[i].I_value + controllers[i].D_value)
                        endpoint_error[i] = measurements[i].value - endpoint[i]
                endpoint_error[3] = endpoint_error[3]*30  # scale swing error, [0, 1.571] to [0, 45], i.e., 2 degrees are penalized same as 1 cm on actuator

                # print(controllers[0].set_point, controllers[0].PID, controllers[0].getError())
                # Update PWM, saturation implemented in Servo class
                for a in actuators:
                    a.update_servo()
                    # print(a.actuator_name + ': ' + str(a.duty_set))

                # Data logging mode 3 (autonomous)
                try:
                    data.log([loop_start - start] +                 # Run-time clock
                             [b.value for b in measurements] +      # BM, ST, BK, SW Measurements
                             [a.duty_set for a in actuators] +      # BM, ST, BK, SW Duty Cycle Cmd
                             [c.getError() for c in controllers])   # BM, ST, BK, SW Error
                except NameError:
                    pass

            for a in actuators:  # Reset all duty cycles between trajectories
                a.duty_set = a.duty_mid
                a.update_servo()

except KeyboardInterrupt:
    print '\nQuitting'
finally:
    print '\nClosing PWM signals...'
    for a in actuators:
        a.duty_set = a.duty_mid
        a.update_servo()
    time.sleep(1)
    for a in actuators:
        a.close_servo()
    if 'data' in locals():
        notes = raw_input('Notes about this trial: ')
        n = open('data/metadata.csv', 'a')
        n.write(filename + ',' + notes)
        n.close()
